<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: panels/source/arrangers/Arranger.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: panels/source/arrangers/Arranger.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(function (enyo, scope) {

	/**
	* _enyo.Arranger_ is an {@link enyo.Layout} that considers one of the
	* controls it lays out as active. The other controls are placed relative to
	* the active control as makes sense for the layout.
	*
	* Arranger supports dynamic layouts, meaning it's possible to transition
	* between its layouts	via animation. Typically, arrangers should lay out
	* controls using CSS transforms, since these are optimized for animation. To
	* support this, the controls in an Arranger are absolutely positioned, and
	* the Arranger kind has an {@link enyo.Arranger#accelerated} property, which marks controls for
	* CSS compositing. The default setting of `'auto'` ensures that this will
	* occur if enabled by the platform.
	*
	* For more information, see the documentation on
	* [Arrangers](building-apps/layout/arrangers.html) in the Enyo Developer Guide.
	*
	* @class  enyo.Arranger
	* @extends enyo.Layout
	* @public
	*/
	enyo.kind(
		/** @lends  enyo.Arranger.prototype */ {
		
		/**
		* @private
		*/
		name: 'enyo.Arranger',
		
		/**
		* @private
		*/
		kind: 'Layout',
		
		/**
		* @private
		*/
		layoutClass: 'enyo-arranger',

		/**
		* Flag indicating whether the Arranger should lay out controls using CSS
		* compositing. The default setting ('auto') will mark controls for compositing
		* if the platform supports it.
		*
		* @protected
		*/
		accelerated: 'auto',

		/**
		* Property of the drag event, used to calculate the amount that a drag will
		* move the layout
		*
		* @private
		*/
		dragProp: 'ddx',

		/**
		* Property of the drag event, used to calculate the direction of the drag
		*
		* @private
		*/
		dragDirectionProp: 'xDirection',

		/**
		* Property of the drag event, used to calculate whether a drag should occur
		*
		* @private
		*/
		canDragProp: 'horizontal',

		/**
		* If set to true, transitions between non-adjacent arrangements will go
		* through the intermediate arrangements. This is useful when direct
		* transitions between arrangements would be visually jarring.
		*
		* @protected
		*/
		incrementalPoints: false,

		/**
		* Called when removing an arranger (e.g., when switching a Panels control to a
		* different _arrangerKind_). Subclasses should implement this function to
		* reset whatever properties they've changed on child controls. Note that you
		* _must_ call the superclass implementation in your subclass's _destroy()_
		* function.
		*
		* @method
		* @private
		*/
		destroy: enyo.inherit(function (sup) {
			return function () {
				var c$ = this.container.getPanels();
				for (var i=0, c; (c=c$[i]); i++) {
					c._arranger = null;
				}
				sup.apply(this, arguments);
			};
		}),

		/**
		* Arranges the given array of `controls` in the layout specified by
		* `index`. When implementing this method, rather than apply styling
		* directly to controls, call {@link enyo.Arranger#arrangeControl} and
		* pass in an arrangement object with styling settings. The styles will
		* then be applied via {@link enyo.Arranger#flowControl}.
		*
		* @param {enyo.Control[]} controls
		* @param {Number} index
		* @virtual
		* @protected
		*/
		arrange: function (controls, index) {
		},

		/**
		* Sizes the controls in the layout. This method is called only at reflow time.
		* Note that the sizing operation has been separated from the layout done in
		* {@link enyo.Arranger#arrange} because it is expensive and not suitable for dynamic layout.
		*
		* @virtual
		* @protected
		*/
		size: function () {
		},

		/**
		* Called when a layout transition begins. Implement this method to perform
		* tasks that should only occur when a transition starts; for example, some
		* controls could be shown or hidden. In addition, the `transitionPoints`
		* array may be set on the container to dictate the named arrangments
		* between which the transition occurs.
		*
		* @private
		*/
		start: function () {
			var f = this.container.fromIndex, t = this.container.toIndex;
			var p$ = this.container.transitionPoints = [f];
			// optionally add a transition point for each index between from and to.
			if (this.incrementalPoints) {
				var d = Math.abs(t - f) - 2;
				var i = f;
				while (d >= 0) {
					i = i + (t &lt; f ? -1 : 1);
					p$.push(i);
					d--;
				}
			}
			p$.push(this.container.toIndex);
		},
		/**
		* Called when a layout transition completes. Implement this method to
		* perform tasks that should only occur when a transition ends; for
		* example, some controls could be shown or hidden.
		*
		* @virtual
		* @protected
		*/
		finish: function () {
		},

		/**
		* Called when dragging the layout, this method returns the difference in
		* pixels between the arrangement `a0` for layout setting `i0`	and
		* arrangement `a1` for layout setting `i1`. This data is used to calculate
		* the percentage that a drag should move the layout between two active states.
		*
		* @param {Number} i0 - Initial layout setting
		* @param {Object} a0 - Initial arrangement
		* @param {Number} i1 - Target layout setting
		* @param {Object} a1 - Target arrangement
		* @virtual
		* @protected
		*/
		calcArrangementDifference: function (i0, a0, i1, a1) {
		},
		
		/**
		* @private
		*/
		canDragEvent: function (event) {
			return event[this.canDragProp];
		},
		
		/**
		* @private
		*/
		calcDragDirection: function (event) {
			return event[this.dragDirectionProp];
		},
		
		/**
		* @private
		*/
		calcDrag: function (event) {
			return event[this.dragProp];
		},
		
		/**
		* @private
		*/
		drag: function (dp, an, a, bn, b) {
			var f = this.measureArrangementDelta(-dp, an, a, bn, b);
			return f;
		},
		
		/**
		* @private
		*/
		measureArrangementDelta: function (x, i0, a0, i1, a1) {
			var d = this.calcArrangementDifference(i0, a0, i1, a1);
			var s = d ? x / Math.abs(d) : 0;
			s = s * (this.container.fromIndex > this.container.toIndex ? -1 : 1);
			return s;
		},

		/**
		* Arranges the panels with the panel at `index` as active
		*
		* @param  {Number} index - Index of active panel
		* @private
		*/
		_arrange: function (index) {
			// guard against being called before we've been rendered
			if (!this.containerBounds) {
				this.reflow();
			}
			var c$ = this.getOrderedControls(index);
			this.arrange(c$, index);
		},

		/**
		* Arrange `control` according to a particular `arrangement`.
		*
		* Note that this method doesn't actually modify `control` but rather sets the arragement
		* on a private member of the control to be retrieved by {@link enyo.Panels}
		*
		* @param  {enyo.Control} control
		* @param  {Object} arrangement
		* @private
		*/
		arrangeControl: function (control, arrangement) {
			control._arranger = enyo.mixin(control._arranger || {}, arrangement);
		},
		
		/**
		* Called before HTML is rendered. Applies CSS to panels to ensure GPU acceleration if
		* {@link enyo.Arranger#accelerated} is `true`
		*
		* @private
		*/
		flow: function () {
			this.c$ = [].concat(this.container.getPanels());
			this.controlsIndex = 0;
			for (var i=0, c$=this.container.getPanels(), c; (c=c$[i]); i++) {
				enyo.dom.accelerate(c, !c.preventAccelerate &amp;&amp; this.accelerated);
				if (enyo.platform.safari) {
					// On Safari-desktop, sometimes having the panel's direct child set to accelerate isn't sufficient
					// this is most often the case with Lists contained inside another control, inside a Panels
					var grands=c.children;
					for (var j=0, kid; (kid=grands[j]); j++) {
						enyo.dom.accelerate(kid, this.accelerated);
					}
				}
			}
		},

		/**
		* Called during 'rendered' phase to {@link enyo.Arranger#size} the controls
		*
		* @private
		*/
		reflow: function () {
			var cn = this.container.hasNode();
			this.containerBounds = cn ? {width: cn.clientWidth, height: cn.clientHeight} : {};
			this.size();
		},

		/**
		* If the {@link enyo.Panels} has an arrangement, flows each control according to that
		* arragement
		*
		* @private
		*/
		flowArrangement: function () {
			var a = this.container.arrangement;
			if (a) {
				for (var i=0, c$=this.container.getPanels(), c; (c=c$[i]) &amp;&amp; (a[i]); i++) {
					this.flowControl(c, a[i]);
				}
			}
		},
		/**
		* Lays out the `control` according to the settings stored in the
		* `arragement` object. By default, `flowControl()` will apply settings for
		* left, top, and opacity. This method should only be implemented to apply
		* other settings made via {@link enyo.Arranger#arrangeControl}.
		*
		* @param {enyo.Control} control
		* @param {Object} arrangement
		* @protected
		*/
		flowControl: function (control, arrangement) {
			enyo.Arranger.positionControl(control, arrangement);
			var o = arrangement.opacity;
			if (o != null) {
				enyo.Arranger.opacifyControl(control, o);
			}
		},

		/**
		* Gets an array of controls arranged in state order.
		* note: optimization, dial around a single array.
		*
		* @param  {Number} index     - Index of active panel
		* @return {enyo.Control[]}   - Ordered array of controls
		* @private
		*/
		getOrderedControls: function (index) {
			var whole = Math.floor(index);
			var a = whole - this.controlsIndex;
			var sign = a > 0;
			var c$ = this.c$ || [];
			for (var i=0; i&lt;Math.abs(a); i++) {
				if (sign) {
					c$.push(c$.shift());
				} else {
					c$.unshift(c$.pop());
				}
			}
			this.controlsIndex = whole;
			return c$;
		},
		
		/**
		* @lends  enyo.Arranger
		* @private
		*/
		statics: {
			/**
			* Positions a control via transform: translateX/Y if supported and falls back to left/top if not.
			*
			* @param  {enyo.Control} control - Control to position
			* @param  {Object} bounds        - New bounds for `control`
			* @param  {String} unit          - Unit of `bounds` members
			* @public
			*/
			positionControl: function (control, bounds, unit) {
				var unit = unit || 'px';
				if (!this.updating) {
					// IE10 uses setBounds because of control hit caching problems seem in some apps
					if (enyo.dom.canTransform() &amp;&amp; !control.preventTransform &amp;&amp; !enyo.platform.android &amp;&amp; enyo.platform.ie !== 10) {
						var l = bounds.left, t = bounds.top;
						l = enyo.isString(l) ? l : l &amp;&amp; (l + unit);
						t = enyo.isString(t) ? t : t &amp;&amp; (t + unit);
						enyo.dom.transform(control, {translateX: l || null, translateY: t || null});
					} else {
						// If a previously positioned control has subsequently been marked with
						// preventTransform, we need to clear out any old translation values.
						if (enyo.dom.canTransform() &amp;&amp; control.preventTransform) {
							enyo.dom.transform(control, {translateX: null, translateY: null});
						}
						control.setBounds(bounds, unit);
					}
				}
			},

			/**
			* Sets the `opacity` of a `control`
			*
			* @param  {enyo.Control} inControl
			* @param  {Number} inOpacity
			* @public
			*/
			opacifyControl: function (inControl, inOpacity) {
				var o = inOpacity;
				// FIXME: very high/low settings of opacity can cause a control to
				// blink so cap this here.
				o = o > 0.99 ? 1 : (o &lt; 0.01 ? 0 : o);
				// note: we only care about ie8
				if (enyo.platform.ie &lt; 9) {
					inControl.applyStyle('filter', 'progid:DXImageTransform.Microsoft.Alpha(Opacity=' + (o * 100) + ')');
				} else {
					inControl.applyStyle('opacity', o);
				}
			}
		}
	});

})(enyo, this);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="enyo.Arranger.html">Arranger</a></li><li><a href="enyo.ContextualLayout.html">ContextualLayout</a></li><li><a href="enyo.Node.html">Node</a></li><li><a href="enyo.Panels.html">Panels</a></li><li><a href="enyo.Slideable.html">Slideable</a></li></ul><h3>Events</h3><ul><li><a href="enyo.Node.html#event:event:onDestroyed">event:onDestroyed</a></li><li><a href="enyo.Node.html#event:event:onExpand">event:onExpand</a></li><li><a href="enyo.Node.html#event:event:onNodeDblClick">event:onNodeDblClick</a></li><li><a href="enyo.Node.html#event:event:onNodeTap">event:onNodeTap</a></li><li><a href="enyo.Panels.html#event:event:onTransitionFinish">event:onTransitionFinish</a></li><li><a href="enyo.Panels.html#event:event:onTransitionStart">event:onTransitionStart</a></li><li><a href="enyo.Slideable.html#event:event:onAnimateFinish">event:onAnimateFinish</a></li><li><a href="enyo.Slideable.html#event:event:onChange">event:onChange</a></li></ul><h3>Global</h3><ul><li><a href="global.html#animate">animate</a></li><li><a href="global.html#buildReorderContainer">buildReorderContainer</a></li><li><a href="global.html#calcNewDragPosition">calcNewDragPosition</a></li><li><a href="global.html#checkForAutoScroll">checkForAutoScroll</a></li><li><a href="global.html#cleanupMemory">cleanupMemory</a></li><li><a href="global.html#completeFinishReordering">completeFinishReordering</a></li><li><a href="global.html#createPlaceholderNode">createPlaceholderNode</a></li><li><a href="global.html#defaultScale">defaultScale</a></li><li><a href="global.html#deselect">deselect</a></li><li><a href="global.html#dragProp">dragProp</a></li><li><a href="global.html#finishReordering">finishReordering</a></li><li><a href="global.html#flow">flow</a></li><li><a href="global.html#getSelection">getSelection</a></li><li><a href="global.html#horizontalDragPropagation">horizontalDragPropagation</a></li><li><a href="global.html#incrementalPoints">incrementalPoints</a></li><li><a href="global.html#isSwiping">isSwiping</a></li><li><a href="global.html#lowMemory">lowMemory</a></li><li><a href="global.html#movePlaceholderToIndex">movePlaceholderToIndex</a></li><li><a href="global.html#noStretch">noStretch</a></li><li><a href="global.html#peekWidth">peekWidth</a></li><li><a href="global.html#performOnRow">performOnRow</a></li><li><a href="global.html#positionReorderContainer">positionReorderContainer</a></li><li><a href="global.html#reflow">reflow</a></li><li><a href="global.html#renderRow">renderRow</a></li><li><a href="global.html#reorderScroll">reorderScroll</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#select">select</a></li><li><a href="global.html#shouldStartReordering">shouldStartReordering</a></li><li><a href="global.html#startSwipe">startSwipe</a></li><li><a href="global.html#swipeDrag">swipeDrag</a></li><li><a href="global.html#swipeDragStart">swipeDragStart</a></li><li><a href="global.html#thumb">thumb</a></li><li><a href="global.html#touchOverscroll">touchOverscroll</a></li><li><a href="global.html#updatePagePositions">updatePagePositions</a></li><li><a href="global.html#updatePageSize">updatePageSize</a></li><li><a href="global.html#verticalDragPropagation">verticalDragPropagation</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha9</a> on Mon Jul 14 2014 12:38:50 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
